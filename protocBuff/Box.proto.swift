/// Generated by the Protocol Buffers 3.3.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.16
/// Source file "box.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct BoxRoot {
    public static let `default` = BoxRoot()
    public var extensionRegistry:ExtensionRegistry

    init() {
        extensionRegistry = ExtensionRegistry()
        registerAllExtensions(registry: extensionRegistry)
    }
    public func registerAllExtensions(registry: ExtensionRegistry) {
    }
}

final public class Box : GeneratedMessage {

    public static func == (lhs: Box, rhs: Box) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasCode == rhs.hasCode) && (!lhs.hasCode || lhs.code == rhs.code)
        fieldCheck = fieldCheck && (lhs.hasMsg == rhs.hasMsg) && (!lhs.hasMsg || lhs.msg == rhs.msg)
        fieldCheck = fieldCheck && (lhs.hasService == rhs.hasService) && (!lhs.hasService || lhs.service == rhs.service)
        fieldCheck = fieldCheck && (lhs.hasSendMessageRequest == rhs.hasSendMessageRequest) && (!lhs.hasSendMessageRequest || lhs.sendMessageRequest == rhs.sendMessageRequest)
        fieldCheck = fieldCheck && (lhs.hasGetPictureRequest == rhs.hasGetPictureRequest) && (!lhs.hasGetPictureRequest || lhs.getPictureRequest == rhs.getPictureRequest)
        fieldCheck = fieldCheck && (lhs.hasSendMessageAck == rhs.hasSendMessageAck) && (!lhs.hasSendMessageAck || lhs.sendMessageAck == rhs.sendMessageAck)
        fieldCheck = fieldCheck && (lhs.hasGetPictureAck == rhs.hasGetPictureAck) && (!lhs.hasGetPictureAck || lhs.getPictureAck == rhs.getPictureAck)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }



    //OneOf declaration start

    /// 响应报文
    public enum DataAck {
        case OneOfDataAckNotSet

        public func checkOneOfIsSet() -> Bool {
            switch self {
            case .OneOfDataAckNotSet: return false
            default: return true
            }
        }
        case SendMessageRequest(SendMessageRequest)

        public static func getSendMessageRequest(_ value:DataAck) -> SendMessageRequest? {
            switch value {
            case .SendMessageRequest(let enumValue):
                return enumValue
                default: return nil
            }
        }
        case GetPictureRequest(GetPictureRequest)

        public static func getGetPictureRequest(_ value:DataAck) -> GetPictureRequest? {
            switch value {
            case .GetPictureRequest(let enumValue):
                return enumValue
                default: return nil
            }
        }
    }
    //OneOf declaration end

    fileprivate var storageDataAck:Box.DataAck =  Box.DataAck.OneOfDataAckNotSet
    public func getOneOfDataAck() ->  Box.DataAck {
        let copyObjectDataAck = storageDataAck
        return copyObjectDataAck
    }


    //OneOf declaration start

    /// 发送报文
    public enum DataRequest {
        case OneOfDataRequestNotSet

        public func checkOneOfIsSet() -> Bool {
            switch self {
            case .OneOfDataRequestNotSet: return false
            default: return true
            }
        }
        case SendMessageAck(SendMessageAck)

        public static func getSendMessageAck(_ value:DataRequest) -> SendMessageAck? {
            switch value {
            case .SendMessageAck(let enumValue):
                return enumValue
                default: return nil
            }
        }
        case GetPictureAck(GetPictureAck)

        public static func getGetPictureAck(_ value:DataRequest) -> GetPictureAck? {
            switch value {
            case .GetPictureAck(let enumValue):
                return enumValue
                default: return nil
            }
        }
    }
    //OneOf declaration end

    fileprivate var storageDataRequest:Box.DataRequest =  Box.DataRequest.OneOfDataRequestNotSet
    public func getOneOfDataRequest() ->  Box.DataRequest {
        let copyObjectDataRequest = storageDataRequest
        return copyObjectDataRequest
    }


        //Enum type declaration start 

        public enum Service:Int32, GeneratedEnum {
            case heartBeat = 0
            case sendMesaage = 1
            case sendMesaageResponse = 2
            case getPicture = 3
            case getPictureResponse = 4
            public func toString() -> String {
                switch self {
                case .heartBeat: return "heartBeat"
                case .sendMesaage: return "sendMesaage"
                case .sendMesaageResponse: return "sendMesaageResponse"
                case .getPicture: return "getPicture"
                case .getPictureResponse: return "getPictureResponse"
                }
            }
            public static func fromString(_ str:String) throws -> Box.Service {
                switch str {
                case "heartBeat":    return .heartBeat
                case "sendMesaage":    return .sendMesaage
                case "sendMesaageResponse":    return .sendMesaageResponse
                case "getPicture":    return .getPicture
                case "getPictureResponse":    return .getPictureResponse
                default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
                }
            }
            public var debugDescription:String { return getDescription() }
            public var description:String { return getDescription() }
            private func getDescription() -> String { 
                switch self {
                case .heartBeat: return ".heartBeat"
                case .sendMesaage: return ".sendMesaage"
                case .sendMesaageResponse: return ".sendMesaageResponse"
                case .getPicture: return ".getPicture"
                case .getPictureResponse: return ".getPictureResponse"
                }
            }
            public var hashValue:Int {
                return self.rawValue.hashValue
            }
            public static func ==(lhs:Service, rhs:Service) -> Bool {
                return lhs.hashValue == rhs.hashValue
            }
        }

        //Enum type declaration end 



        //Enum type declaration start 

        public enum Code:Int32, GeneratedEnum {
            case sucess = 0
            case authError = 1
            public func toString() -> String {
                switch self {
                case .sucess: return "sucess"
                case .authError: return "authError"
                }
            }
            public static func fromString(_ str:String) throws -> Box.Code {
                switch str {
                case "sucess":    return .sucess
                case "authError":    return .authError
                default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
                }
            }
            public var debugDescription:String { return getDescription() }
            public var description:String { return getDescription() }
            private func getDescription() -> String { 
                switch self {
                case .sucess: return ".sucess"
                case .authError: return ".authError"
                }
            }
            public var hashValue:Int {
                return self.rawValue.hashValue
            }
            public static func ==(lhs:Code, rhs:Code) -> Bool {
                return lhs.hashValue == rhs.hashValue
            }
        }

        //Enum type declaration end 

    public fileprivate(set) var code:Box.Code = Box.Code.sucess
    public fileprivate(set) var hasCode:Bool = false
    public fileprivate(set) var msg:String! = nil
    public fileprivate(set) var hasMsg:Bool = false

    public fileprivate(set) var service:Box.Service = Box.Service.heartBeat
    public fileprivate(set) var hasService:Bool = false
    public fileprivate(set) var sendMessageRequest:SendMessageRequest!{
        get {
            return Box.DataAck.getSendMessageRequest(storageDataAck)
        }
        set (newvalue) {
            storageDataAck = Box.DataAck.SendMessageRequest(newvalue)
        }
    }
    public fileprivate(set) var hasSendMessageRequest:Bool {
        get {
            guard let _ = Box.DataAck.getSendMessageRequest(storageDataAck) else {
                return false
            }
            return true
        }
        set(newValue) {
        }
    }
    public fileprivate(set) var getPictureRequest:GetPictureRequest!{
        get {
            return Box.DataAck.getGetPictureRequest(storageDataAck)
        }
        set (newvalue) {
            storageDataAck = Box.DataAck.GetPictureRequest(newvalue)
        }
    }
    public fileprivate(set) var hasGetPictureRequest:Bool {
        get {
            guard let _ = Box.DataAck.getGetPictureRequest(storageDataAck) else {
                return false
            }
            return true
        }
        set(newValue) {
        }
    }
    public fileprivate(set) var sendMessageAck:SendMessageAck!{
        get {
            return Box.DataRequest.getSendMessageAck(storageDataRequest)
        }
        set (newvalue) {
            storageDataRequest = Box.DataRequest.SendMessageAck(newvalue)
        }
    }
    public fileprivate(set) var hasSendMessageAck:Bool {
        get {
            guard let _ = Box.DataRequest.getSendMessageAck(storageDataRequest) else {
                return false
            }
            return true
        }
        set(newValue) {
        }
    }
    public fileprivate(set) var getPictureAck:GetPictureAck!{
        get {
            return Box.DataRequest.getGetPictureAck(storageDataRequest)
        }
        set (newvalue) {
            storageDataRequest = Box.DataRequest.GetPictureAck(newvalue)
        }
    }
    public fileprivate(set) var hasGetPictureAck:Bool {
        get {
            guard let _ = Box.DataRequest.getGetPictureAck(storageDataRequest) else {
                return false
            }
            return true
        }
        set(newValue) {
        }
    }
    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasCode {
            try codedOutputStream.writeEnum(fieldNumber: 1, value:code.rawValue)
        }
        if hasMsg {
            try codedOutputStream.writeString(fieldNumber: 2, value:msg)
        }
        if hasService {
            try codedOutputStream.writeEnum(fieldNumber: 3, value:service.rawValue)
        }
        if hasSendMessageRequest {
            try codedOutputStream.writeMessage(fieldNumber: 11, value:sendMessageRequest)
        }
        if hasGetPictureRequest {
            try codedOutputStream.writeMessage(fieldNumber: 12, value:getPictureRequest)
        }
        if hasSendMessageAck {
            try codedOutputStream.writeMessage(fieldNumber: 51, value:sendMessageAck)
        }
        if hasGetPictureAck {
            try codedOutputStream.writeMessage(fieldNumber: 52, value:getPictureAck)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if (hasCode) {
            serialize_size += code.rawValue.computeEnumSize(fieldNumber: 1)
        }
        if hasMsg {
            serialize_size += msg.computeStringSize(fieldNumber: 2)
        }
        if (hasService) {
            serialize_size += service.rawValue.computeEnumSize(fieldNumber: 3)
        }
        if hasSendMessageRequest {
            if let varSizesendMessageRequest = sendMessageRequest?.computeMessageSize(fieldNumber: 11) {
                serialize_size += varSizesendMessageRequest
            }
        }
        if hasGetPictureRequest {
            if let varSizegetPictureRequest = getPictureRequest?.computeMessageSize(fieldNumber: 12) {
                serialize_size += varSizegetPictureRequest
            }
        }
        if hasSendMessageAck {
            if let varSizesendMessageAck = sendMessageAck?.computeMessageSize(fieldNumber: 51) {
                serialize_size += varSizesendMessageAck
            }
        }
        if hasGetPictureAck {
            if let varSizegetPictureAck = getPictureAck?.computeMessageSize(fieldNumber: 52) {
                serialize_size += varSizegetPictureAck
            }
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Box.Builder {
        return Box.classBuilder() as! Box.Builder
    }
    public func getBuilder() -> Box.Builder {
        return classBuilder() as! Box.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Box.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Box.Builder()
    }
    public func toBuilder() throws -> Box.Builder {
        return try Box.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Box) throws -> Box.Builder {
        return try Box.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasCode {
            jsonMap["code"] = code.toString()
        }
        if hasMsg {
            jsonMap["msg"] = msg
        }
        if hasService {
            jsonMap["service"] = service.toString()
        }
        if hasSendMessageRequest {
            jsonMap["sendMessageRequest"] = try sendMessageRequest.encode()
        }
        if hasGetPictureRequest {
            jsonMap["getPictureRequest"] = try getPictureRequest.encode()
        }
        if hasSendMessageAck {
            jsonMap["sendMessageAck"] = try sendMessageAck.encode()
        }
        if hasGetPictureAck {
            jsonMap["getPictureAck"] = try getPictureAck.encode()
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Box {
        return try Box.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Box {
        return try Box.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if (hasCode) {
            output += "\(indent) code: \(code.description)\n"
        }
        if hasMsg {
            output += "\(indent) msg: \(msg) \n"
        }
        if (hasService) {
            output += "\(indent) service: \(service.description)\n"
        }
        if hasSendMessageRequest {
            output += "\(indent) sendMessageRequest {\n"
            if let outDescSendMessageRequest = sendMessageRequest {
                output += try outDescSendMessageRequest.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        if hasGetPictureRequest {
            output += "\(indent) getPictureRequest {\n"
            if let outDescGetPictureRequest = getPictureRequest {
                output += try outDescGetPictureRequest.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        if hasSendMessageAck {
            output += "\(indent) sendMessageAck {\n"
            if let outDescSendMessageAck = sendMessageAck {
                output += try outDescSendMessageAck.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        if hasGetPictureAck {
            output += "\(indent) getPictureAck {\n"
            if let outDescGetPictureAck = getPictureAck {
                output += try outDescGetPictureAck.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasCode {
                 hashCode = (hashCode &* 31) &+ code.hashValue
            }
            if hasMsg {
                hashCode = (hashCode &* 31) &+ msg.hashValue
            }
            if hasService {
                 hashCode = (hashCode &* 31) &+ service.hashValue
            }
            if hasSendMessageRequest {
                if let hashValuesendMessageRequest = sendMessageRequest?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuesendMessageRequest
                }
            }
            if hasGetPictureRequest {
                if let hashValuegetPictureRequest = getPictureRequest?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuegetPictureRequest
                }
            }
            if hasSendMessageAck {
                if let hashValuesendMessageAck = sendMessageAck?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuesendMessageAck
                }
            }
            if hasGetPictureAck {
                if let hashValuegetPictureAck = getPictureAck?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuegetPictureAck
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Box"
    }
    override public func className() -> String {
        return "Box"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Box = Box()
        public func getMessage() -> Box {
            return builderResult
        }

        required override public init () {
            super.init()
        }
            public var code:Box.Code {
                get {
                    return builderResult.code
                }
                set (value) {
                    builderResult.hasCode = true
                    builderResult.code = value
                }
            }
            public var hasCode:Bool{
                get {
                    return builderResult.hasCode
                }
            }
        @discardableResult
            public func setCode(_ value:Box.Code) -> Box.Builder {
              self.code = value
              return self
            }
        @discardableResult
            public func clearCode() -> Box.Builder {
               builderResult.hasCode = false
               builderResult.code = .sucess
               return self
            }
        public var msg:String {
            get {
                return builderResult.msg
            }
            set (value) {
                builderResult.hasMsg = true
                builderResult.msg = value
            }
        }
        public var hasMsg:Bool {
            get {
                return builderResult.hasMsg
            }
        }
        @discardableResult
        public func setMsg(_ value:String) -> Box.Builder {
            self.msg = value
            return self
        }
        @discardableResult
        public func clearMsg() -> Box.Builder{
            builderResult.hasMsg = false
            builderResult.msg = nil
            return self
        }
            public var service:Box.Service {
                get {
                    return builderResult.service
                }
                set (value) {
                    builderResult.hasService = true
                    builderResult.service = value
                }
            }
            public var hasService:Bool{
                get {
                    return builderResult.hasService
                }
            }
        @discardableResult
            public func setService(_ value:Box.Service) -> Box.Builder {
              self.service = value
              return self
            }
        @discardableResult
            public func clearService() -> Box.Builder {
               builderResult.hasService = false
               builderResult.service = .heartBeat
               return self
            }
        public var sendMessageRequest:SendMessageRequest! {
            get {
                if sendMessageRequestBuilder_ != nil {
                    builderResult.sendMessageRequest = sendMessageRequestBuilder_.getMessage()
                }
                return builderResult.sendMessageRequest
            }
            set (value) {
                builderResult.hasSendMessageRequest = true
                builderResult.sendMessageRequest = value
            }
        }
        public var hasSendMessageRequest:Bool {
            get {
                return builderResult.hasSendMessageRequest
            }
        }
        fileprivate var sendMessageRequestBuilder_:SendMessageRequest.Builder! {
            didSet {
                builderResult.hasSendMessageRequest = true
            }
        }
        public func getSendMessageRequestBuilder() -> SendMessageRequest.Builder {
            if sendMessageRequestBuilder_ == nil {
                sendMessageRequestBuilder_ = SendMessageRequest.Builder()
                builderResult.sendMessageRequest = sendMessageRequestBuilder_.getMessage()
                if sendMessageRequest != nil {
                    try! sendMessageRequestBuilder_.mergeFrom(other: sendMessageRequest)
                }
            }
            return sendMessageRequestBuilder_
        }
        @discardableResult
        public func setSendMessageRequest(_ value:SendMessageRequest!) -> Box.Builder {
            self.sendMessageRequest = value
            return self
        }
        @discardableResult
        public func mergeSendMessageRequest(value:SendMessageRequest) throws -> Box.Builder {
            if builderResult.hasSendMessageRequest {
                builderResult.sendMessageRequest = try SendMessageRequest.builderWithPrototype(prototype:builderResult.sendMessageRequest).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.sendMessageRequest = value
            }
            builderResult.hasSendMessageRequest = true
            return self
        }
        @discardableResult
        public func clearSendMessageRequest() -> Box.Builder {
            sendMessageRequestBuilder_ = nil
            builderResult.hasSendMessageRequest = false
            builderResult.sendMessageRequest = nil
            return self
        }
        public var getPictureRequest:GetPictureRequest! {
            get {
                if getPictureRequestBuilder_ != nil {
                    builderResult.getPictureRequest = getPictureRequestBuilder_.getMessage()
                }
                return builderResult.getPictureRequest
            }
            set (value) {
                builderResult.hasGetPictureRequest = true
                builderResult.getPictureRequest = value
            }
        }
        public var hasGetPictureRequest:Bool {
            get {
                return builderResult.hasGetPictureRequest
            }
        }
        fileprivate var getPictureRequestBuilder_:GetPictureRequest.Builder! {
            didSet {
                builderResult.hasGetPictureRequest = true
            }
        }
        public func getGetPictureRequestBuilder() -> GetPictureRequest.Builder {
            if getPictureRequestBuilder_ == nil {
                getPictureRequestBuilder_ = GetPictureRequest.Builder()
                builderResult.getPictureRequest = getPictureRequestBuilder_.getMessage()
                if getPictureRequest != nil {
                    try! getPictureRequestBuilder_.mergeFrom(other: getPictureRequest)
                }
            }
            return getPictureRequestBuilder_
        }
        @discardableResult
        public func setGetPictureRequest(_ value:GetPictureRequest!) -> Box.Builder {
            self.getPictureRequest = value
            return self
        }
        @discardableResult
        public func mergeGetPictureRequest(value:GetPictureRequest) throws -> Box.Builder {
            if builderResult.hasGetPictureRequest {
                builderResult.getPictureRequest = try GetPictureRequest.builderWithPrototype(prototype:builderResult.getPictureRequest).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.getPictureRequest = value
            }
            builderResult.hasGetPictureRequest = true
            return self
        }
        @discardableResult
        public func clearGetPictureRequest() -> Box.Builder {
            getPictureRequestBuilder_ = nil
            builderResult.hasGetPictureRequest = false
            builderResult.getPictureRequest = nil
            return self
        }
        public var sendMessageAck:SendMessageAck! {
            get {
                if sendMessageAckBuilder_ != nil {
                    builderResult.sendMessageAck = sendMessageAckBuilder_.getMessage()
                }
                return builderResult.sendMessageAck
            }
            set (value) {
                builderResult.hasSendMessageAck = true
                builderResult.sendMessageAck = value
            }
        }
        public var hasSendMessageAck:Bool {
            get {
                return builderResult.hasSendMessageAck
            }
        }
        fileprivate var sendMessageAckBuilder_:SendMessageAck.Builder! {
            didSet {
                builderResult.hasSendMessageAck = true
            }
        }
        public func getSendMessageAckBuilder() -> SendMessageAck.Builder {
            if sendMessageAckBuilder_ == nil {
                sendMessageAckBuilder_ = SendMessageAck.Builder()
                builderResult.sendMessageAck = sendMessageAckBuilder_.getMessage()
                if sendMessageAck != nil {
                    try! sendMessageAckBuilder_.mergeFrom(other: sendMessageAck)
                }
            }
            return sendMessageAckBuilder_
        }
        @discardableResult
        public func setSendMessageAck(_ value:SendMessageAck!) -> Box.Builder {
            self.sendMessageAck = value
            return self
        }
        @discardableResult
        public func mergeSendMessageAck(value:SendMessageAck) throws -> Box.Builder {
            if builderResult.hasSendMessageAck {
                builderResult.sendMessageAck = try SendMessageAck.builderWithPrototype(prototype:builderResult.sendMessageAck).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.sendMessageAck = value
            }
            builderResult.hasSendMessageAck = true
            return self
        }
        @discardableResult
        public func clearSendMessageAck() -> Box.Builder {
            sendMessageAckBuilder_ = nil
            builderResult.hasSendMessageAck = false
            builderResult.sendMessageAck = nil
            return self
        }
        public var getPictureAck:GetPictureAck! {
            get {
                if getPictureAckBuilder_ != nil {
                    builderResult.getPictureAck = getPictureAckBuilder_.getMessage()
                }
                return builderResult.getPictureAck
            }
            set (value) {
                builderResult.hasGetPictureAck = true
                builderResult.getPictureAck = value
            }
        }
        public var hasGetPictureAck:Bool {
            get {
                return builderResult.hasGetPictureAck
            }
        }
        fileprivate var getPictureAckBuilder_:GetPictureAck.Builder! {
            didSet {
                builderResult.hasGetPictureAck = true
            }
        }
        public func getGetPictureAckBuilder() -> GetPictureAck.Builder {
            if getPictureAckBuilder_ == nil {
                getPictureAckBuilder_ = GetPictureAck.Builder()
                builderResult.getPictureAck = getPictureAckBuilder_.getMessage()
                if getPictureAck != nil {
                    try! getPictureAckBuilder_.mergeFrom(other: getPictureAck)
                }
            }
            return getPictureAckBuilder_
        }
        @discardableResult
        public func setGetPictureAck(_ value:GetPictureAck!) -> Box.Builder {
            self.getPictureAck = value
            return self
        }
        @discardableResult
        public func mergeGetPictureAck(value:GetPictureAck) throws -> Box.Builder {
            if builderResult.hasGetPictureAck {
                builderResult.getPictureAck = try GetPictureAck.builderWithPrototype(prototype:builderResult.getPictureAck).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.getPictureAck = value
            }
            builderResult.hasGetPictureAck = true
            return self
        }
        @discardableResult
        public func clearGetPictureAck() -> Box.Builder {
            getPictureAckBuilder_ = nil
            builderResult.hasGetPictureAck = false
            builderResult.getPictureAck = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Box.Builder {
            builderResult = Box()
            return self
        }
        override public func clone() throws -> Box.Builder {
            return try Box.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Box {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Box {
            let returnMe:Box = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Box) throws -> Box.Builder {
            if other == Box() {
                return self
            }
            if other.hasCode {
                code = other.code
            }
            if other.hasMsg {
                msg = other.msg
            }
            if other.hasService {
                service = other.service
            }
            if (other.hasSendMessageRequest) {
                try mergeSendMessageRequest(value: other.sendMessageRequest)
            }
            if (other.hasGetPictureRequest) {
                try mergeGetPictureRequest(value: other.getPictureRequest)
            }
            if (other.hasSendMessageAck) {
                try mergeSendMessageAck(value: other.sendMessageAck)
            }
            if (other.hasGetPictureAck) {
                try mergeGetPictureAck(value: other.getPictureAck)
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Box.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Box.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    let valueIntcode = try codedInputStream.readEnum()
                    if let enumscode = Box.Code(rawValue:valueIntcode){
                        code = enumscode
                    } else {
                        try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntcode))
                    }

                case 18:
                    msg = try codedInputStream.readString()

                case 24:
                    let valueIntservice = try codedInputStream.readEnum()
                    if let enumsservice = Box.Service(rawValue:valueIntservice){
                        service = enumsservice
                    } else {
                        try unknownFieldsBuilder.mergeVarintField(fieldNumber: 3, value:Int64(valueIntservice))
                    }

                case 90:
                    let subBuilder:SendMessageRequest.Builder = SendMessageRequest.Builder()
                    if hasSendMessageRequest {
                        try subBuilder.mergeFrom(other: sendMessageRequest)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    sendMessageRequest = subBuilder.buildPartial()

                case 98:
                    let subBuilder:GetPictureRequest.Builder = GetPictureRequest.Builder()
                    if hasGetPictureRequest {
                        try subBuilder.mergeFrom(other: getPictureRequest)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    getPictureRequest = subBuilder.buildPartial()

                case 410:
                    let subBuilder:SendMessageAck.Builder = SendMessageAck.Builder()
                    if hasSendMessageAck {
                        try subBuilder.mergeFrom(other: sendMessageAck)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    sendMessageAck = subBuilder.buildPartial()

                case 418:
                    let subBuilder:GetPictureAck.Builder = GetPictureAck.Builder()
                    if hasGetPictureAck {
                        try subBuilder.mergeFrom(other: getPictureAck)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    getPictureAck = subBuilder.buildPartial()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Box.Builder {
            let resultDecodedBuilder = Box.Builder()
            if let jsonValueCode = jsonMap["code"] as? String {
                resultDecodedBuilder.code = try Box.Code.fromString(jsonValueCode)
            }
            if let jsonValueMsg = jsonMap["msg"] as? String {
                resultDecodedBuilder.msg = jsonValueMsg
            }
            if let jsonValueService = jsonMap["service"] as? String {
                resultDecodedBuilder.service = try Box.Service.fromString(jsonValueService)
            }
            if let jsonValueSendMessageRequest = jsonMap["sendMessageRequest"] as? Dictionary<String,Any> {
                resultDecodedBuilder.sendMessageRequest = try SendMessageRequest.Builder.decodeToBuilder(jsonMap:jsonValueSendMessageRequest).build()

            }
            if let jsonValueGetPictureRequest = jsonMap["getPictureRequest"] as? Dictionary<String,Any> {
                resultDecodedBuilder.getPictureRequest = try GetPictureRequest.Builder.decodeToBuilder(jsonMap:jsonValueGetPictureRequest).build()

            }
            if let jsonValueSendMessageAck = jsonMap["sendMessageAck"] as? Dictionary<String,Any> {
                resultDecodedBuilder.sendMessageAck = try SendMessageAck.Builder.decodeToBuilder(jsonMap:jsonValueSendMessageAck).build()

            }
            if let jsonValueGetPictureAck = jsonMap["getPictureAck"] as? Dictionary<String,Any> {
                resultDecodedBuilder.getPictureAck = try GetPictureAck.Builder.decodeToBuilder(jsonMap:jsonValueGetPictureAck).build()

            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Box.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Box.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class SendMessageRequest : GeneratedMessage {

    public static func == (lhs: SendMessageRequest, rhs: SendMessageRequest) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasMessage == rhs.hasMessage) && (!lhs.hasMessage || lhs.message == rhs.message)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var message:String! = nil
    public fileprivate(set) var hasMessage:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasMessage {
            try codedOutputStream.writeString(fieldNumber: 1, value:message)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasMessage {
            serialize_size += message.computeStringSize(fieldNumber: 1)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> SendMessageRequest.Builder {
        return SendMessageRequest.classBuilder() as! SendMessageRequest.Builder
    }
    public func getBuilder() -> SendMessageRequest.Builder {
        return classBuilder() as! SendMessageRequest.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return SendMessageRequest.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return SendMessageRequest.Builder()
    }
    public func toBuilder() throws -> SendMessageRequest.Builder {
        return try SendMessageRequest.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:SendMessageRequest) throws -> SendMessageRequest.Builder {
        return try SendMessageRequest.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasMessage {
            jsonMap["message"] = message
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> SendMessageRequest {
        return try SendMessageRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> SendMessageRequest {
        return try SendMessageRequest.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasMessage {
            output += "\(indent) message: \(message) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasMessage {
                hashCode = (hashCode &* 31) &+ message.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "SendMessageRequest"
    }
    override public func className() -> String {
        return "SendMessageRequest"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:SendMessageRequest = SendMessageRequest()
        public func getMessage() -> SendMessageRequest {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var message:String {
            get {
                return builderResult.message
            }
            set (value) {
                builderResult.hasMessage = true
                builderResult.message = value
            }
        }
        public var hasMessage:Bool {
            get {
                return builderResult.hasMessage
            }
        }
        @discardableResult
        public func setMessage(_ value:String) -> SendMessageRequest.Builder {
            self.message = value
            return self
        }
        @discardableResult
        public func clearMessage() -> SendMessageRequest.Builder{
            builderResult.hasMessage = false
            builderResult.message = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> SendMessageRequest.Builder {
            builderResult = SendMessageRequest()
            return self
        }
        override public func clone() throws -> SendMessageRequest.Builder {
            return try SendMessageRequest.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> SendMessageRequest {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> SendMessageRequest {
            let returnMe:SendMessageRequest = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:SendMessageRequest) throws -> SendMessageRequest.Builder {
            if other == SendMessageRequest() {
                return self
            }
            if other.hasMessage {
                message = other.message
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> SendMessageRequest.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SendMessageRequest.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    message = try codedInputStream.readString()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> SendMessageRequest.Builder {
            let resultDecodedBuilder = SendMessageRequest.Builder()
            if let jsonValueMessage = jsonMap["message"] as? String {
                resultDecodedBuilder.message = jsonValueMessage
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> SendMessageRequest.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try SendMessageRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class SendMessageAck : GeneratedMessage {

    public static func == (lhs: SendMessageAck, rhs: SendMessageAck) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasAckMessage == rhs.hasAckMessage) && (!lhs.hasAckMessage || lhs.ackMessage == rhs.ackMessage)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var ackMessage:String! = nil
    public fileprivate(set) var hasAckMessage:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasAckMessage {
            try codedOutputStream.writeString(fieldNumber: 1, value:ackMessage)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasAckMessage {
            serialize_size += ackMessage.computeStringSize(fieldNumber: 1)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> SendMessageAck.Builder {
        return SendMessageAck.classBuilder() as! SendMessageAck.Builder
    }
    public func getBuilder() -> SendMessageAck.Builder {
        return classBuilder() as! SendMessageAck.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return SendMessageAck.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return SendMessageAck.Builder()
    }
    public func toBuilder() throws -> SendMessageAck.Builder {
        return try SendMessageAck.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:SendMessageAck) throws -> SendMessageAck.Builder {
        return try SendMessageAck.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasAckMessage {
            jsonMap["ackMessage"] = ackMessage
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> SendMessageAck {
        return try SendMessageAck.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> SendMessageAck {
        return try SendMessageAck.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasAckMessage {
            output += "\(indent) ackMessage: \(ackMessage) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasAckMessage {
                hashCode = (hashCode &* 31) &+ ackMessage.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "SendMessageAck"
    }
    override public func className() -> String {
        return "SendMessageAck"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:SendMessageAck = SendMessageAck()
        public func getMessage() -> SendMessageAck {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var ackMessage:String {
            get {
                return builderResult.ackMessage
            }
            set (value) {
                builderResult.hasAckMessage = true
                builderResult.ackMessage = value
            }
        }
        public var hasAckMessage:Bool {
            get {
                return builderResult.hasAckMessage
            }
        }
        @discardableResult
        public func setAckMessage(_ value:String) -> SendMessageAck.Builder {
            self.ackMessage = value
            return self
        }
        @discardableResult
        public func clearAckMessage() -> SendMessageAck.Builder{
            builderResult.hasAckMessage = false
            builderResult.ackMessage = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> SendMessageAck.Builder {
            builderResult = SendMessageAck()
            return self
        }
        override public func clone() throws -> SendMessageAck.Builder {
            return try SendMessageAck.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> SendMessageAck {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> SendMessageAck {
            let returnMe:SendMessageAck = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:SendMessageAck) throws -> SendMessageAck.Builder {
            if other == SendMessageAck() {
                return self
            }
            if other.hasAckMessage {
                ackMessage = other.ackMessage
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> SendMessageAck.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SendMessageAck.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    ackMessage = try codedInputStream.readString()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> SendMessageAck.Builder {
            let resultDecodedBuilder = SendMessageAck.Builder()
            if let jsonValueAckMessage = jsonMap["ackMessage"] as? String {
                resultDecodedBuilder.ackMessage = jsonValueAckMessage
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> SendMessageAck.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try SendMessageAck.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class GetPictureRequest : GeneratedMessage {

    public static func == (lhs: GetPictureRequest, rhs: GetPictureRequest) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasUrl == rhs.hasUrl) && (!lhs.hasUrl || lhs.url == rhs.url)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var url:String! = nil
    public fileprivate(set) var hasUrl:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasUrl {
            try codedOutputStream.writeString(fieldNumber: 1, value:url)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasUrl {
            serialize_size += url.computeStringSize(fieldNumber: 1)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> GetPictureRequest.Builder {
        return GetPictureRequest.classBuilder() as! GetPictureRequest.Builder
    }
    public func getBuilder() -> GetPictureRequest.Builder {
        return classBuilder() as! GetPictureRequest.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return GetPictureRequest.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return GetPictureRequest.Builder()
    }
    public func toBuilder() throws -> GetPictureRequest.Builder {
        return try GetPictureRequest.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:GetPictureRequest) throws -> GetPictureRequest.Builder {
        return try GetPictureRequest.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasUrl {
            jsonMap["url"] = url
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> GetPictureRequest {
        return try GetPictureRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> GetPictureRequest {
        return try GetPictureRequest.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasUrl {
            output += "\(indent) url: \(url) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasUrl {
                hashCode = (hashCode &* 31) &+ url.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "GetPictureRequest"
    }
    override public func className() -> String {
        return "GetPictureRequest"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:GetPictureRequest = GetPictureRequest()
        public func getMessage() -> GetPictureRequest {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var url:String {
            get {
                return builderResult.url
            }
            set (value) {
                builderResult.hasUrl = true
                builderResult.url = value
            }
        }
        public var hasUrl:Bool {
            get {
                return builderResult.hasUrl
            }
        }
        @discardableResult
        public func setUrl(_ value:String) -> GetPictureRequest.Builder {
            self.url = value
            return self
        }
        @discardableResult
        public func clearUrl() -> GetPictureRequest.Builder{
            builderResult.hasUrl = false
            builderResult.url = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> GetPictureRequest.Builder {
            builderResult = GetPictureRequest()
            return self
        }
        override public func clone() throws -> GetPictureRequest.Builder {
            return try GetPictureRequest.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> GetPictureRequest {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> GetPictureRequest {
            let returnMe:GetPictureRequest = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:GetPictureRequest) throws -> GetPictureRequest.Builder {
            if other == GetPictureRequest() {
                return self
            }
            if other.hasUrl {
                url = other.url
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> GetPictureRequest.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GetPictureRequest.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    url = try codedInputStream.readString()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> GetPictureRequest.Builder {
            let resultDecodedBuilder = GetPictureRequest.Builder()
            if let jsonValueUrl = jsonMap["url"] as? String {
                resultDecodedBuilder.url = jsonValueUrl
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> GetPictureRequest.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try GetPictureRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class GetPictureAck : GeneratedMessage {

    public static func == (lhs: GetPictureAck, rhs: GetPictureAck) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasPictureData == rhs.hasPictureData) && (!lhs.hasPictureData || lhs.pictureData == rhs.pictureData)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var pictureData:Data! = nil
    public fileprivate(set) var hasPictureData:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasPictureData {
            try codedOutputStream.writeData(fieldNumber: 1, value:pictureData)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasPictureData {
            serialize_size += pictureData.computeDataSize(fieldNumber: 1)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> GetPictureAck.Builder {
        return GetPictureAck.classBuilder() as! GetPictureAck.Builder
    }
    public func getBuilder() -> GetPictureAck.Builder {
        return classBuilder() as! GetPictureAck.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return GetPictureAck.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return GetPictureAck.Builder()
    }
    public func toBuilder() throws -> GetPictureAck.Builder {
        return try GetPictureAck.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:GetPictureAck) throws -> GetPictureAck.Builder {
        return try GetPictureAck.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasPictureData {
            jsonMap["pictureData"] = pictureData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> GetPictureAck {
        return try GetPictureAck.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> GetPictureAck {
        return try GetPictureAck.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasPictureData {
            output += "\(indent) pictureData: \(pictureData) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasPictureData {
                hashCode = (hashCode &* 31) &+ pictureData.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "GetPictureAck"
    }
    override public func className() -> String {
        return "GetPictureAck"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:GetPictureAck = GetPictureAck()
        public func getMessage() -> GetPictureAck {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var pictureData:Data {
            get {
                return builderResult.pictureData
            }
            set (value) {
                builderResult.hasPictureData = true
                builderResult.pictureData = value
            }
        }
        public var hasPictureData:Bool {
            get {
                return builderResult.hasPictureData
            }
        }
        @discardableResult
        public func setPictureData(_ value:Data) -> GetPictureAck.Builder {
            self.pictureData = value
            return self
        }
        @discardableResult
        public func clearPictureData() -> GetPictureAck.Builder{
            builderResult.hasPictureData = false
            builderResult.pictureData = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> GetPictureAck.Builder {
            builderResult = GetPictureAck()
            return self
        }
        override public func clone() throws -> GetPictureAck.Builder {
            return try GetPictureAck.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> GetPictureAck {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> GetPictureAck {
            let returnMe:GetPictureAck = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:GetPictureAck) throws -> GetPictureAck.Builder {
            if other == GetPictureAck() {
                return self
            }
            if other.hasPictureData {
                pictureData = other.pictureData
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> GetPictureAck.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GetPictureAck.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    pictureData = try codedInputStream.readData()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> GetPictureAck.Builder {
            let resultDecodedBuilder = GetPictureAck.Builder()
            if let jsonValuePictureData = jsonMap["pictureData"] as? String {
                resultDecodedBuilder.pictureData = Data(base64Encoded:jsonValuePictureData, options: Data.Base64DecodingOptions(rawValue:0))!
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> GetPictureAck.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try GetPictureAck.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

extension Box: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Box> {
        var mergedArray = Array<Box>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Box? {
        return try Box.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Box {
        return try Box.Builder().mergeFrom(data: data, extensionRegistry:BoxRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Box {
        return try Box.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Box {
        return try Box.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Box {
        return try Box.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Box {
        return try Box.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Box {
        return try Box.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "code": return self.code
        case "msg": return self.msg
        case "service": return self.service
        case "sendMessageRequest": return self.sendMessageRequest
        case "getPictureRequest": return self.getPictureRequest
        case "sendMessageAck": return self.sendMessageAck
        case "getPictureAck": return self.getPictureAck
        default: return nil
        }
    }
}
extension Box.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "code": return self.code
            case "msg": return self.msg
            case "service": return self.service
            case "sendMessageRequest": return self.sendMessageRequest
            case "getPictureRequest": return self.getPictureRequest
            case "sendMessageAck": return self.sendMessageAck
            case "getPictureAck": return self.getPictureAck
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "code":
                guard let newSubscriptValue = newSubscriptValue as? Box.Code else {
                    return
                }
                self.code = newSubscriptValue
            case "msg":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.msg = newSubscriptValue
            case "service":
                guard let newSubscriptValue = newSubscriptValue as? Box.Service else {
                    return
                }
                self.service = newSubscriptValue
            case "sendMessageRequest":
                guard let newSubscriptValue = newSubscriptValue as? SendMessageRequest else {
                    return
                }
                self.sendMessageRequest = newSubscriptValue
            case "getPictureRequest":
                guard let newSubscriptValue = newSubscriptValue as? GetPictureRequest else {
                    return
                }
                self.getPictureRequest = newSubscriptValue
            case "sendMessageAck":
                guard let newSubscriptValue = newSubscriptValue as? SendMessageAck else {
                    return
                }
                self.sendMessageAck = newSubscriptValue
            case "getPictureAck":
                guard let newSubscriptValue = newSubscriptValue as? GetPictureAck else {
                    return
                }
                self.getPictureAck = newSubscriptValue
            default: return
            }
        }
    }
}
extension SendMessageRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<SendMessageRequest> {
        var mergedArray = Array<SendMessageRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> SendMessageRequest? {
        return try SendMessageRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> SendMessageRequest {
        return try SendMessageRequest.Builder().mergeFrom(data: data, extensionRegistry:BoxRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> SendMessageRequest {
        return try SendMessageRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> SendMessageRequest {
        return try SendMessageRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> SendMessageRequest {
        return try SendMessageRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> SendMessageRequest {
        return try SendMessageRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SendMessageRequest {
        return try SendMessageRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "message": return self.message
        default: return nil
        }
    }
}
extension SendMessageRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "message": return self.message
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "message":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.message = newSubscriptValue
            default: return
            }
        }
    }
}
extension SendMessageAck: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<SendMessageAck> {
        var mergedArray = Array<SendMessageAck>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> SendMessageAck? {
        return try SendMessageAck.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> SendMessageAck {
        return try SendMessageAck.Builder().mergeFrom(data: data, extensionRegistry:BoxRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> SendMessageAck {
        return try SendMessageAck.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> SendMessageAck {
        return try SendMessageAck.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> SendMessageAck {
        return try SendMessageAck.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> SendMessageAck {
        return try SendMessageAck.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SendMessageAck {
        return try SendMessageAck.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "ackMessage": return self.ackMessage
        default: return nil
        }
    }
}
extension SendMessageAck.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "ackMessage": return self.ackMessage
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "ackMessage":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.ackMessage = newSubscriptValue
            default: return
            }
        }
    }
}
extension GetPictureRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<GetPictureRequest> {
        var mergedArray = Array<GetPictureRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> GetPictureRequest? {
        return try GetPictureRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> GetPictureRequest {
        return try GetPictureRequest.Builder().mergeFrom(data: data, extensionRegistry:BoxRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> GetPictureRequest {
        return try GetPictureRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> GetPictureRequest {
        return try GetPictureRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> GetPictureRequest {
        return try GetPictureRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> GetPictureRequest {
        return try GetPictureRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GetPictureRequest {
        return try GetPictureRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "url": return self.url
        default: return nil
        }
    }
}
extension GetPictureRequest.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "url": return self.url
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "url":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.url = newSubscriptValue
            default: return
            }
        }
    }
}
extension GetPictureAck: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<GetPictureAck> {
        var mergedArray = Array<GetPictureAck>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> GetPictureAck? {
        return try GetPictureAck.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> GetPictureAck {
        return try GetPictureAck.Builder().mergeFrom(data: data, extensionRegistry:BoxRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> GetPictureAck {
        return try GetPictureAck.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> GetPictureAck {
        return try GetPictureAck.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> GetPictureAck {
        return try GetPictureAck.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> GetPictureAck {
        return try GetPictureAck.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> GetPictureAck {
        return try GetPictureAck.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "pictureData": return self.pictureData
        default: return nil
        }
    }
}
extension GetPictureAck.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "pictureData": return self.pictureData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "pictureData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.pictureData = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
